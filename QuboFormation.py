{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "585a5dc4-5a9c-4cf4-9c82-23b3435c40b8",
   "metadata": {},
   "outputs": [],
   "source": [
    "\"\"\"\n",
    "Module for building the QUBO formulation for RNA secondary structure prediction.\n",
    "\n",
    "This module translates the RNA folding problem into a Quadratic Unconstrained\n",
    "Binary Optimization (QUBO) problem, which can then be solved by quantum\n",
    "or classical optimizers.\n",
    "\n",
    "--- Quadratic Unconstrained Binary Optimization (QUBO) ---\n",
    "\n",
    "In the context of RNA folding, the problem is modeled by assigning a binary\n",
    "variable to each potential structural component. Here, the component is a\n",
    "\"quartet,\" a stable stack of two adjacent base pairs.\n",
    "\n",
    "- Binary Variable: For each possible quartet `q_i`, we define a binary variable.\n",
    "  - `q_i = 1` means \"we are choosing to include this specific quartet in our\n",
    "    final folded structure.\"\n",
    "  - `q_i = 0` means we are not.\n",
    "\n",
    "- Objective Function: The goal is to find the combination of 1s and 0s (the\n",
    "  selection of quartets) that results in the minimum possible total free energy\n",
    "  of the folded structure. This is known as finding the Minimum Free Energy (MFE)\n",
    "  structure. The objective function is a mathematical formula that calculates this\n",
    "  total energy for any given set of choices.\n",
    "\n",
    "  Total Energy = (Sum of individual quartet energies) + (Sum of interaction rewards/penalties)\n",
    "\n",
    "--- From Constrained to Unconstrained Problem ---\n",
    "\n",
    "A key rule in RNA secondary structure is that base pairs cannot \"cross.\" In a\n",
    "formal constrained optimization, this would be a separate rule like `q_i + q_j <= 1`\n",
    "for any two crossing quartets `i` and `j`.\n",
    "\n",
    "To make this an *unconstrained* problem suitable for QUBO, we move this rule\n",
    "into the objective function itself. We add a large positive energy penalty (`t`)\n",
    "to the objective function for any two incompatible (crossing) quartets. The\n",
    "term `t * q_i * q_j` is added to the total energy. If an optimizer tries to\n",
    "select both `q_i` and `q_j` (so `q_i=1` and `q_j=1`), the total energy gets a\n",
    "massive penalty, making that solution highly unfavorable. The optimizer will\n",
    "naturally discard it in favor of lower-energy, valid structures.\n",
    "\n",
    "--- QUBO Objective Function Components ---\n",
    "\n",
    "The QUBO objective function is a summation of linear and quadratic terms.\n",
    "\n",
    "1.  **Linear Terms (Individual Costs/Rewards):**\n",
    "    Each potential quartet has an intrinsic stability, corresponding to a certain\n",
    "    amount of free energy, `e_qi`. These values are typically negative (favorable)\n",
    "    and are determined experimentally. The linear part of the objective function\n",
    "    is the sum of the energies of all chosen quartets.\n",
    "\n",
    "    `F_linear = Σ (e_qi * q_i)` for all possible quartets `q_i`\n",
    "\n",
    "2.  **Quadratic Terms (Interaction Costs/Rewards):**\n",
    "    These terms represent the bonus or penalty that arises from the interaction\n",
    "    between two choices (i.e., selecting two different quartets).\n",
    "\n",
    "    -   **Stacking Rewards:** When two quartets are stacked directly on top of each\n",
    "        other, they create a more stable helix. This is represented by an energy\n",
    "        reward `r` (a negative value). The term `r * q_i * q_j` is added for each\n",
    "        pair of stackable quartets `i` and `j`. This reward is only applied if\n",
    "        both quartets are chosen (`q_i=1` and `q_j=1`).\n",
    "\n",
    "        `F_reward = Σ (r * q_i * q_j)` for all stackable pairs `(q_i, q_j)`\n",
    "\n",
    "    -   **Crossing Penalties:** As described above, a large penalty `t` (a positive\n",
    "        value) is added for any pair of quartets that cross each other.\n",
    "\n",
    "        `F_penalty = Σ (t * q_i * q_j)` for all crossing pairs `(q_i, q_j)`\n",
    "\n",
    "--- Final QUBO Formulation Implemented ---\n",
    "\n",
    "The complete objective function to be minimized is:\n",
    "\n",
    "`Min F(q) = F_linear + F_reward + F_penalty`\n",
    "`Min F(q) = Σ(e_qi * q_i) + Σ(r * q_i * q_j) + Σ(t * q_i * q_j)`\n",
    "\n",
    "This module's `build_rna_qubo` function constructs this exact objective\n",
    "function as a `qiskit_optimization.problems.QuadraticProgram` object.\n",
    "\n",
    "Note: This model can be extended with other penalties, such as for a helix\n",
    "ending in a (U,A) pair, by adding more linear and quadratic terms to the\n",
    "objective function.\n",
    "\"\"\"\n",
    "# Import the necessary Qiskit class\n",
    "from qiskit_optimization.problems import QuadraticProgram\n",
    "\n",
    "# --- 1. Helper Functions for Pre-processing ---\n",
    "\n",
    "def is_valid_pair(b1, b2):\n",
    "    \"\"\"Checks if two bases form a valid pair (Watson-Crick or wobble).\"\"\"\n",
    "    return tuple(sorted((b1, b2))) in [('A', 'U'), ('C', 'G'), ('G', 'U')]\n",
    "\n",
    "def generate_quartets(sequence):\n",
    "    \"\"\"Generates all possible valid quartets from an RNA sequence.\"\"\"\n",
    "    n = len(sequence)\n",
    "    quartets = []\n",
    "    # A quartet is two stacked pairs (i, j) and (i+1, j-1)\n",
    "    # The variable is represented as a tuple: (i, j, i+1, j-1)\n",
    "    for i in range(n):\n",
    "        for j in range(i + 4, n): # Ensure a minimal loop size\n",
    "            # Check if the outer pair (i, j) is valid\n",
    "            if is_valid_pair(sequence[i], sequence[j]):\n",
    "                # Check if the inner pair (i+1, j-1) is valid\n",
    "                if is_valid_pair(sequence[i+1], sequence[j-1]):\n",
    "                    quartets.append((i, j, i+1, j-1))\n",
    "    return quartets\n",
    "\n",
    "def are_quartets_crossing(q1, q2):\n",
    "    \"\"\"Checks if two quartets contain crossing pairs.\"\"\"\n",
    "    # q1 = (i, j, i+1, j-1) and q2 = (k, l, k+1, l-1)\n",
    "    i, j = q1[0], q1[1]\n",
    "    k, l = q2[0], q2[1]\n",
    "    # Simple crossing condition: i < k < j < l or k < i < l < j\n",
    "    return (i < k and k < j and j < l) or \\\n",
    "           (k < i and i < l and l < j)\n",
    "\n",
    "def are_quartets_stacked(q1, q2):\n",
    "    \"\"\"Checks if q2 is stacked directly on top of q1.\"\"\"\n",
    "    # q1 = (i, j, i+1, j-1) and q2 should be (i+2, j-2, ...)\n",
    "    return q1[2] + 1 == q2[0] and q1[3] - 1 == q2[1]\n",
    "\n",
    "\n",
    "# --- 2. The Main QUBO Building Function ---\n",
    "\n",
    "def build_rna_qubo(sequence, energy_data, stacking_reward, crossing_penalty):\n",
    "    \"\"\"\n",
    "    Builds the QUBO for RNA folding as a Qiskit QuadraticProgram.\n",
    "\n",
    "    Args:\n",
    "        sequence (str): The RNA sequence (e.g., \"GCGAUAGCGC\").\n",
    "        energy_data (dict): A dictionary mapping quartet tuples to their free energy.\n",
    "        stacking_reward (float): The energy reward for stacked quartets (should be negative).\n",
    "        crossing_penalty (float): The energy penalty for crossing quartets (should be large and positive).\n",
    "\n",
    "    Returns:\n",
    "        QuadraticProgram: The Qiskit object representing the QUBO.\n",
    "    \"\"\"\n",
    "    # This pre-processing step generates the variables of our problem [cite: 152]\n",
    "    all_quartets = generate_quartets(sequence)\n",
    "    \n",
    "    # Initialize the Quadratic Program for our QUBO\n",
    "    qp = QuadraticProgram(\"RNA-Folding-QUBO\")\n",
    "\n",
    "    # --- 3. Add Binary Variables ---\n",
    "    # For each possible quartet, create a binary variable q_i \n",
    "    for quartet in all_quartets:\n",
    "        qp.binary_var(name=str(quartet))\n",
    "\n",
    "    # --- 4. Build the Objective Function ---\n",
    "    linear_terms = {}\n",
    "    quadratic_terms = {}\n",
    "\n",
    "    # Add Linear Terms: The base energy for each chosen quartet \n",
    "    # This corresponds to the sum: Σ e_qi * q_i\n",
    "    for quartet in all_quartets:\n",
    "        q_name = str(quartet)\n",
    "        linear_terms[q_name] = energy_data.get(quartet, 0)\n",
    "\n",
    "    # Add Quadratic Terms: Rewards and penalties for interactions\n",
    "    for i in range(len(all_quartets)):\n",
    "        for j in range(i + 1, len(all_quartets)):\n",
    "            q1 = all_quartets[i]\n",
    "            q2 = all_quartets[j]\n",
    "            q1_name = str(q1)\n",
    "            q2_name = str(q2)\n",
    "\n",
    "            # Add stacking reward: r * q_i * q_j \n",
    "            if are_quartets_stacked(q1, q2) or are_quartets_stacked(q2, q1):\n",
    "                quadratic_terms[(q1_name, q2_name)] = stacking_reward\n",
    "            \n",
    "            # Add crossing penalty: t * q_i * q_j [cite: 153, 171]\n",
    "            if are_quartets_crossing(q1, q2):\n",
    "                # We add to the existing value in case a pair has multiple interactions\n",
    "                current_val = quadratic_terms.get((q1_name, q2_name), 0)\n",
    "                quadratic_terms[(q1_name, q2_name)] = current_val + crossing_penalty\n",
    "    \n",
    "    # Set the objective in the QuadraticProgram object\n",
    "    qp.minimize(linear=linear_terms, quadratic=quadratic_terms)\n",
    "    \n",
    "    return qp\n",
    "\n",
    "\n",
    "# --- 5. Example Usage ---\n",
    "if __name__ == \"__main__\":\n",
    "    # A simple RNA sequence\n",
    "    rna_sequence = \"GCGAUAGCGC\"\n",
    "    \n",
    "    # Dummy data for the example (in a real scenario, this comes from a database)\n",
    "    # Let's say we found two possible quartets:\n",
    "    q1_tuple = (0, 9, 1, 8)  # Pairs G(0)-C(9) and C(1)-G(8)\n",
    "    q2_tuple = (2, 7, 3, 6)  # Pairs G(2)-C(7) and A(3)-G(6) - Let's assume A-G is valid for this example\n",
    "    \n",
    "    dummy_energy_data = {\n",
    "        q1_tuple: -3.3,\n",
    "        q2_tuple: -2.1,\n",
    "    }\n",
    "    \n",
    "    # Define reward and penalty values\n",
    "    r = -1.5  # Stacking reward\n",
    "    t = 100.0   # Crossing penalty\n",
    "    \n",
    "    # Build the QUBO\n",
    "    rna_qubo = build_rna_qubo(\n",
    "        sequence=rna_sequence,\n",
    "        energy_data=dummy_energy_data,\n",
    "        stacking_reward=r,\n",
    "        crossing_penalty=t\n",
    "    )\n",
    "    \n",
    "    # Print the QUBO in a human-readable format\n",
    "    print(\"--- Generated QUBO ---\")\n",
    "    print(rna_qubo.export_as_lp_string())"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python [conda env:base] *",
   "language": "python",
   "name": "conda-base-py"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.12.2"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
